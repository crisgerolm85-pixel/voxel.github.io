<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport"
content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Voxel World Builder + ZIP Save/Load</title>

<style>
body{margin:0;overflow:hidden;font-family:sans-serif;touch-action:none;background:#333}
#ui-top{position:absolute;top:15px;left:15px;right:15px;display:flex;flex-direction:column;gap:8px;pointer-events:none}
.card{background:#fff;padding:12px;border-radius:15px;pointer-events:auto;box-shadow:0 4px 15px rgba(0,0,0,.4)}
.row{display:flex;gap:8px;align-items:center}
.controls-bottom{position:absolute;bottom:35px;left:0;right:0;display:flex;justify-content:center;gap:15px;pointer-events:none}
.btn{width:60px;height:60px;border-radius:50%;border:none;font-size:24px;background:#fff;pointer-events:auto;box-shadow:0 5px 15px rgba(0,0,0,.3)}
.btn.active{background:#ff4757;color:#fff}
.btn-rect{flex:1;padding:8px;border-radius:8px;border:1px solid #ccc;font-size:12px}
#mode-text{font-size:11px;font-weight:bold}
#texture-modal{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:15px;z-index:1000;box-shadow:0 0 50px rgba(0,0,0,.5)}
</style>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>

<div id="ui-top">
<div class="card">
<div class="row">
<input type="color" id="colorPicker" value="#00ff88">
<input type="file" id="upload" accept="image/*">
<div id="mode-text">Color s√≥lido</div>
</div>
<div class="row">
<button class="btn-rect" id="exportBtn">üíæ Exportar ZIP</button>
<button class="btn-rect" id="importBtn">üìÇ Importar</button>
<input type="file" id="importFile" style="display:none" accept=".zip,.json">
</div>
</div>
</div>

<div id="texture-modal">
<h4>Textura faltante</h4>
<p>Sub√≠ la imagen para los bloques fucsia</p>
<input type="file" id="relinkTexture" accept="image/*">
</div>

<div class="controls-bottom">
<button id="deleteMode" class="btn">üóëÔ∏è</button>
<button id="reset" class="btn">üßπ</button>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

let scene,camera,renderer,controls,raycaster;
let objects=[];
let ghostMesh,ghostMat;
let isDeleteMode=false;

let textureLibrary={};
let textureActive=false;
let currentTexID=null;
let activeColor="#00ff88";

const cubeGeo=new THREE.BoxGeometry(50,50,50);
const pointer=new THREE.Vector2();

init();
animate();

function init(){
scene=new THREE.Scene();
scene.background=new THREE.Color(0xd0d0d0);

camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,1,10000);
camera.position.set(600,800,1200);

renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,2));
scene.add(new THREE.GridHelper(1000,20));

const plane=new THREE.Mesh(
new THREE.PlaneGeometry(1000,1000).rotateX(-Math.PI/2),
new THREE.MeshBasicMaterial({visible:false})
);
scene.add(plane);
objects.push(plane);

ghostMat=new THREE.MeshBasicMaterial({color:0x00ff88,transparent:true,opacity:.4});
ghostMesh=new THREE.Mesh(cubeGeo,ghostMat);
scene.add(ghostMesh);

controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;
raycaster=new THREE.Raycaster();

setupUI();
}

function setupUI(){
colorPicker.oninput=e=>{
textureActive=false;
activeColor=e.target.value;
ghostMat.map=null;
ghostMat.color.set(activeColor);
modeText.innerText="Color s√≥lido";
};

upload.onchange=e=>{
const file=e.target.files[0];
if(!file)return;
const url=URL.createObjectURL(file);
new THREE.TextureLoader().load(url,tex=>{
tex.colorSpace=THREE.SRGBColorSpace;
tex.magFilter=THREE.NearestFilter;
currentTexID="tex_"+Date.now();
textureLibrary[currentTexID]=tex;
textureActive=true;
ghostMat.color.set(0xffffff);
ghostMat.map=tex;
ghostMat.needsUpdate=true;
modeText.innerText="Textura";
});
};

exportBtn.onclick=exportZIP;
importBtn.onclick=()=>importFile.click();
importFile.onchange=importWorld;

deleteMode.onclick=()=>{
isDeleteMode=!isDeleteMode;
deleteMode.classList.toggle("active",isDeleteMode);
};

reset.onclick=()=>{if(confirm("¬øBorrar todo?"))clearWorld();};

renderer.domElement.addEventListener("pointerdown",placeBlock);
renderer.domElement.addEventListener("pointermove",updateGhost);
window.addEventListener("resize",onResize);
}

/* ===== EXPORT ZIP ONLY ===== */
async function exportZIP(){
const world=objects.slice(1).map(o=>({
pos:o.position.toArray(),
color:o.material.color?.getHex?.(),
texID:o.userData.texID||null
}));

const zip=new JSZip();
zip.file("world.json",JSON.stringify(world));
const folder=zip.folder("textures");

for(const id in textureLibrary){
const tex=textureLibrary[id];
const canvas=document.createElement("canvas");
canvas.width=tex.image.width;
canvas.height=tex.image.height;
canvas.getContext("2d").drawImage(tex.image,0,0);
const blob=await new Promise(r=>canvas.toBlob(r));
folder.file(id+".png",blob);
}

download(await zip.generateAsync({type:"blob"}),"mundo.zip");
}

function download(blob,name){
const a=document.createElement("a");
a.href=URL.createObjectURL(blob);
a.download=name;
a.click();
}

/* ===== IMPORT ===== */
async function importWorld(e){
const file=e.target.files[0];
if(!file)return;

clearWorld();
textureLibrary={};

if(file.name.endsWith(".zip")){
const zip=await JSZip.loadAsync(file);
const promises=[];

for(const path in zip.files){
if(path.startsWith("textures/")&&path.endsWith(".png")){
const id=path.replace("textures/","").replace(".png","");
promises.push(
zip.file(path).async("blob").then(async blob=>{
const bmp=await createImageBitmap(blob);
const tex=new THREE.Texture(bmp);
tex.colorSpace=THREE.SRGBColorSpace;
tex.magFilter=THREE.NearestFilter;
tex.needsUpdate=true;
textureLibrary[id]=tex;
})
);
}
}

await Promise.all(promises);
const data=JSON.parse(await zip.file("world.json").async("string"));
loadWorld(data);
return;
}

/* Compatibilidad JSON antigua */
const r=new FileReader();
r.onload=e=>loadWorld(JSON.parse(e.target.result));
r.readAsText(file);
}

function loadWorld(data){
const missing=new Set();

data.forEach(d=>{
let mat;
if(d.texID && textureLibrary[d.texID]){
mat=new THREE.MeshBasicMaterial({map:textureLibrary[d.texID]});
}else if(d.texID){
mat=new THREE.MeshLambertMaterial({color:0xff00ff});
missing.add(d.texID);
}else{
mat=new THREE.MeshLambertMaterial({color:d.color});
}

const v=new THREE.Mesh(cubeGeo,mat);
v.position.fromArray(d.pos);
v.userData.texID=d.texID;
scene.add(v);
objects.push(v);
});

if(missing.size>0) askForTextures([...missing]);
}

/* ===== CORE ===== */
function clearWorld(){
while(objects.length>1) scene.remove(objects.pop());
}

function updateGhost(e){
pointer.set((e.clientX/innerWidth)*2-1,-(e.clientY/innerHeight)*2+1);
raycaster.setFromCamera(pointer,camera);
const hit=raycaster.intersectObjects(objects)[0];
if(hit&&!isDeleteMode){
ghostMesh.position.copy(hit.point).add(hit.face.normal);
ghostMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
}
}

function placeBlock(e){
pointer.set((e.clientX/innerWidth)*2-1,-(e.clientY/innerHeight)*2+1);
raycaster.setFromCamera(pointer,camera);
const hit=raycaster.intersectObjects(objects)[0];
if(!hit)return;

if(isDeleteMode&&hit.object!==objects[0]){
scene.remove(hit.object);
objects.splice(objects.indexOf(hit.object),1);
return;
}

const mat=textureActive&&currentTexID
?new THREE.MeshBasicMaterial({map:textureLibrary[currentTexID]})
:new THREE.MeshLambertMaterial({color:activeColor});

const v=new THREE.Mesh(cubeGeo,mat);
v.position.copy(hit.point).add(hit.face.normal);
v.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
v.userData.texID=textureActive?currentTexID:null;
scene.add(v);
objects.push(v);
}

async function askForTextures(ids){
const modal=document.getElementById("texture-modal");
const input=document.getElementById("relinkTexture");

for(const id of ids){
modal.style.display="block";
const file=await new Promise(r=>input.onchange=e=>r(e.target.files[0]));
const bmp=await createImageBitmap(file);
const tex=new THREE.Texture(bmp);
tex.colorSpace=THREE.SRGBColorSpace;
tex.magFilter=THREE.NearestFilter;
tex.needsUpdate=true;
textureLibrary[id]=tex;

objects.forEach(o=>{
if(o.userData.texID===id){
o.material=new THREE.MeshBasicMaterial({map:tex});
}
});
input.value="";
}
modal.style.display="none";
}

function onResize(){
camera.aspect=innerWidth/innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth,innerHeight);
}

function animate(){
requestAnimationFrame(animate);
controls.update();
renderer.render(scene,camera);
}
</script>
</body>
</html>
